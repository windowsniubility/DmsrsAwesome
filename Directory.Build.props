<Project>
	<PropertyGroup>
		<LoadingOrder>$(MSBuildThisFileDirectory)$(MSBuildThisFile);$(LoadingOrder)</LoadingOrder>
	</PropertyGroup>
	<!--<Import Project="$([MSBuild]::GetPathOfFileAbove($(MSBuildThisFile), $(MSBuildThisFileDirectory)..))" Condition="Exists($([MSBuild]::GetPathOfFileAbove($(MSBuildThisFile), $(MSBuildThisFileDirectory)..)))" />-->
	<PropertyGroup Label="Config_Default">
		<AssertFolder>assert</AssertFolder>
		<ConfigLinkBase>Properties/root</ConfigLinkBase>
		<CertificateFile>StrongName.snk</CertificateFile>
		<AssemblyName>$(MSBuildProjectName)</AssemblyName>
		<Authors>Jimbo</Authors>
		<Company>DMSRS</Company>
		<PackageId>$(AssemblyName)</PackageId>
		<Title>$(AssemblyName)</Title>
		<PackageLicenseExpression>LGPL</PackageLicenseExpression>
		<RepositoryType>git</RepositoryType>
		<LangVersion>preview</LangVersion>
	</PropertyGroup>
	<PropertyGroup Label="TFM__Default">
		<TFMS_LIB>netstandard2.1</TFMS_LIB>
		<TFMS_Web>net8.0</TFMS_Web>
		<TFMS_NORMAL>net8.0</TFMS_NORMAL>
		<TFMS_TEST>net8.0</TFMS_TEST>
		<TFMS_SINGLE>net8.0</TFMS_SINGLE>
		<TFMS_WINDOWS>net8.0-windows</TFMS_WINDOWS>
	</PropertyGroup>
	<PropertyGroup>
		<PropsDir>$([MSBuild]::NormalizeDirectory($(MSBuildThisFileDirectory)))</PropsDir>
		<AssertDir>$([MSBuild]::NormalizeDirectory($(PropsDir),$(AssertFolder)))</AssertDir>
		<ProjDir>$([MSBuild]::NormalizeDirectory($(MSBuildProjectDirectory)))</ProjDir>
	</PropertyGroup>

	<PropertyGroup Label="Project">
		<BuildInParallel Condition="'$(BuildInParallel)' ==''">true</BuildInParallel>
		<NeutralLanguage>zh-cn</NeutralLanguage>
		<PublishRepositoryUrl>https://gitee.com/dmsrs/dmsrs.git</PublishRepositoryUrl>
		<EnforceCodeStyleInBuild>True</EnforceCodeStyleInBuild>
		<Nullable>enable</Nullable>
		<AllowUnsafeBlocks>True</AllowUnsafeBlocks>
		<RootNamespace>$(MSBuildProjectName.Replace(" ", "_"))</RootNamespace>
		<Optimize Condition="'$(Configuration)'=='Release'">true</Optimize>
		<DebugType>portable</DebugType>
		<BuildOutput>$(PropsDir).build</BuildOutput>
		<BaseOutputPath>$([MSBuild]::NormalizeDirectory($(BuildOutput),"bin",$(MSBuildProjectName)))</BaseOutputPath>
		<BaseIntermediateOutputPath>$([MSBuild]::NormalizeDirectory($(BuildOutput),"obj",$(MSBuildProjectName)))</BaseIntermediateOutputPath>

		<ImplicitUsings>enable</ImplicitUsings>
		<!--<TargetPath>$(BaseOutputPath)$(Platform)$(ProjectName)\bin$(Configuration)$(TargetName)$(TargetExt)</TargetPath>-->
		<RunCodeAnalysis>false</RunCodeAnalysis>
	</PropertyGroup>
	<PropertyGroup Label="Generates">
		<GenerateRuntimeConfigurationFiles>true</GenerateRuntimeConfigurationFiles>
		<GenerateDependencyFile>true</GenerateDependencyFile>
		<GenerateDocumentationFile>true</GenerateDocumentationFile>
		<GeneratePackageOnBuild Condition="'$(IsTestProject)' != 'true' and '$(Configuration)'=='Release'">true</GeneratePackageOnBuild>
		<AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
		<GenerateFullPaths Condition="'$(TERM_PROGRAM)' == 'vscode'">true</GenerateFullPaths>
		<!--如果将 GenerateAssemblyInfo 设置为 false，xunit 无法执行，因为 xunit 需要使用程序集信息来查找测试。-->
		<GenerateAssemblyInfo>true</GenerateAssemblyInfo>
		<GenerateAssemblyVersionAttribute>true</GenerateAssemblyVersionAttribute>
		<GenerateAssemblyFileVersionAttribute>true</GenerateAssemblyFileVersionAttribute>
		<GenerateAssemblyInformationalVersionAttribute>true</GenerateAssemblyInformationalVersionAttribute>
	</PropertyGroup>
	<PropertyGroup Condition="'$(GITHUB_ACTIONS)' == 'true'">
		<ContinuousIntegrationBuild>true</ContinuousIntegrationBuild>
		<!-- Optional: Publish the repository URL in the built .nupkg (in the NuSpec <Repository> element) -->
		<PublishRepositoryUrl>true</PublishRepositoryUrl>
		<!-- 只有在 GitHub 的 Action 构建才能使用源代码链接 -->
		<!-- 源代码链接需要使用 commit 号，而在 GitHub 的 Action 构建的 commit 才是对的 -->
		<!-- 本地构建，也许没有记得 commit 就构建，此时的 nuget 包的源代码是不对的，上传上去会让调试诡异 -->
		<!-- Optional: Embed source files that are not tracked by the source control manager in the PDB -->
		<EmbedUntrackedSources>false</EmbedUntrackedSources>
		<!-- 本地等不需要创建符号文件 -->
		<!-- Optional: Build symbol package (.snupkg) to distribute the PDB containing Source Link -->
		<IncludeSymbols>true</IncludeSymbols>
		<SymbolPackageFormat>snupkg</SymbolPackageFormat>
	</PropertyGroup>
	<!--<ItemDefinitionGroup>
		-->
	<!-- We always want MSBuild properties generated that point at the restored location of each package. -->
	<!--
		<PackageReference GeneratePathProperty="true" />
	</ItemDefinitionGroup>-->

	<Import Project="Directory.Config.props"
	        Condition="Exists('Directory.Config.props')" />

	<PropertyGroup Label="ProjectFilePath">
		<ReadmeInTree>$([MSBuild]::GetPathOfFileAbove('README.md',$(ProjDir)))</ReadmeInTree>
		<ReadmeInTree Condition="'$(ReadmeInTree)'==''">$(AssertDir)README.md</ReadmeInTree>
		<ReadmeInTree Condition="!Exists('$(ReadmeInTree)')">__Unfound_.README.md</ReadmeInTree>

		<IconPngInTree>$([MSBuild]::GetPathOfFileAbove('icon.png',$(ProjDir)))</IconPngInTree>
		<IconPngInTree Condition="'$(IconPngInTree)'==''">$(AssertDir)icon.png</IconPngInTree>
		<IconPngInTree Condition="!Exists('$(IconPngInTree)')">__Unfound_.icon.png</IconPngInTree>

		<AppIcoInTree>$([MSBuild]::GetPathOfFileAbove('app.ico',$(ProjDir)))</AppIcoInTree>
		<AppIcoInTree Condition="'$(AppIcoInTree)'==''">$(AssertDir)app.ico</AppIcoInTree>
		<AppIcoInTree Condition="!Exists('$(AppIcoInTree)')">__Unfound_.app.ico</AppIcoInTree>

		<ThirdPartyNoticesInTree>$([MSBuild]::GetPathOfFileAbove('3rdPartyNotices.txt',$(ProjDir)))</ThirdPartyNoticesInTree>
		<ThirdPartyNoticesInTree Condition="'$(ThirdPartyNoticesInTree)'==''">$(AssertDir)3rdPartyNotices.txt</ThirdPartyNoticesInTree>
		<ThirdPartyNoticesInTree Condition="!Exists('$(ThirdPartyNoticesInTree)')">__Unfound_.3rdPartyNotices.txt</ThirdPartyNoticesInTree>

		<ChangeLogInTree>$([MSBuild]::GetPathOfFileAbove('changelog.md',$(ProjDir)))</ChangeLogInTree>
		<ChangeLogInTree Condition="'$(ChangeLogInTree)'==''">$(AssertDir)changelog.md</ChangeLogInTree>
		<ChangeLogInTree Condition="!Exists('$(ChangeLogInTree)')">__Unfound_.changelog.md</ChangeLogInTree>

		<DescriptionInTree>$([MSBuild]::GetPathOfFileAbove('description.md',$(ProjDir)))</DescriptionInTree>
		<DescriptionInTree Condition="'$(DescriptionInTree)'==''">$(AssertDir)description.md</DescriptionInTree>
		<DescriptionInTree Condition="!Exists('$(DescriptionInTree)')">__Unfound_.description.md</DescriptionInTree>

		<CertificateFileInTree Condition="'$(CertificateFile)'!='' And $([System.IO.Path]::IsPathRooted($(CertificateFile))) And Exists('$(CertificateFile)')">$(CertificateFile)</CertificateFileInTree>
		<CertificateFile Condition="'$(CertificateFile)'!='' And '$(CertificateFileInTree)'==''">$([System.IO.Path]::GetFileName($(CertificateFile)))</CertificateFile>
		<CertificateFileInTree Condition="'$(CertificateFile)'!='' And '$(CertificateFileInTree)'==''">$([MSBuild]::GetPathOfFileAbove($(CertificateFile),$(ProjDir)))</CertificateFileInTree>
		<CertificateFileInTree Condition="'$(CertificateFile)'!='' And '$(CertificateFileInTree)'==''">$(AssertDir)$(CertificateFile)</CertificateFileInTree>
		<CertificateFileInTree Condition="!Exists('$(CertificateFileInTree)')">__Unfound_.$(CertificateFile)</CertificateFileInTree>
	</PropertyGroup>

	<PropertyGroup Condition="'$(CertificateFileInTree)'!='' and Exists('$(CertificateFileInTree)')">
		<SignAssembly>true</SignAssembly>
		<AssemblyOriginatorKeyFile>$(CertificateFileInTree)</AssemblyOriginatorKeyFile>
		<PackageCertificateKeyFile>$(CertificateFileInTree)</PackageCertificateKeyFile>
	</PropertyGroup>
	<ItemGroup>
		<ConfigFile Include="$(PropsDir)**/*.props" Exclude="$(PropsDir)**/*.g.props;$(BuildOutput)/**/*.props" />
		<ConfigFile Include="$(PropsDir)**/*.targets" Exclude="$(PropsDir)**/*.g.targets" />
		<ConfigFile Include="$(PropsDir)**/*.rsp" Exclude="$(PropsDir)**/*.g.rsp" />
		<RootFile Include="$(PropsDir)*.*" Exclude="$(PropsDir)**/*.props;$(PropsDir)**/*.targets;$(PropsDir)**/*.rsp" />
		<RootFile Include="$(PropsDir)/.github/**/*.*" Folder=".github" />
		<RootFile Include="$(PropsDir)/.gitee/**/*.*" Folder=".gitte" />
		<RootFile Include="$(AssertDir)**/*.*" Folder="$(AssertFolder)" />
		<None LinkBase="$(ConfigLinkBase)/Directory.Build" Include="@(ConfigFile)" />
		<None LinkBase="$(ConfigLinkBase)/%(Folder)" Include="@(RootFile)" />
		<!--
		<None LinkBase="$(ConfigLinkBase)/Directory.Build" Include="$(PropsDir)**/*.props" Exclude="$(PropsDir)**/*.g.props;$(BaseOutputPath)**/***.props;$(BaseIntermediateOutputPath)**/***.props">
			<Link>$(ConfigLinkBase)/Directory.Build/%(RecursiveDir)/%(Filename)%(Extension)</Link>
		</None
		-->
		<None LinkBase="$(ConfigLinkBase)" Include="$(MSBuildThisFileDirectory)stylecop.json" Condition="Exists('$(MSBuildThisFileDirectory)stylecop.json')" />
		<None LinkBase="$(ConfigLinkBase)" Include="$(ThirdPartyNoticesInTree)" Pack="true" PackagePath="/" Condition="Exists('$(ThirdPartyNoticesInTree)')" />
		<Compile LinkBase="$(ConfigLinkBase)" Include="$(PropsDir)GlobalUsings.cs" Condition="Exists('$(PropsDir)GlobalUsings.cs')" />
	</ItemGroup>
	<!-- PackageReadmeFile -->

	<Choose>
		<When Condition="Exists('$(ReadmeInTree)')">
			<PropertyGroup>
				<PackageReadmeFile>README.md</PackageReadmeFile>
				<ReadmeFinalPath>$(ReadmeInTree)</ReadmeFinalPath>
			</PropertyGroup>
			<ItemGroup>
				<None Include="$(ReadmeInTree)"
				      Pack="True"
				      PackagePath="/"
				      Visible="True" />
			</ItemGroup>
		</When>
	</Choose>
	<!--PackageIcon-->
	<Choose>
		<When Condition="Exists('$(IconPngInTree)')">
			<PropertyGroup>
				<PackageIcon>icon.png</PackageIcon>
				<PackageIconFinalPath>$(IconPngInTree)</PackageIconFinalPath>
			</PropertyGroup>
			<ItemGroup>
				<None Include="$(IconPngInTree)"
				      Pack="True"
				      PackagePath="/"
				      Visible="True" />
			</ItemGroup>
		</When>
	</Choose>
	<!--ApplicationIcon - Load app.ico file for ApplicationIcon(.exe)-->
	<Choose>
		<When Condition="Exists('$(AppIcoInTree)')">
			<PropertyGroup>
				<ApplicationIcon>$(AppIcoInTree)</ApplicationIcon>
			</PropertyGroup>
			<ItemGroup>
				<!--<None Include="$(AppIcoInTree)" Pack="True" PackagePath="/" Visible="True" />-->
				<EmbeddedResource Include="$(AppIcoInTree)" />
				<Content Include="$(AppIcoInTree)" />
			</ItemGroup>
		</When>
	</Choose>
	<!--PackageReleaseNotes -->
	<Choose>
		<When Condition="Exists('$(ChangeLogInTree)')">
			<PropertyGroup>
				<PackageReleaseNotes>$([System.IO.File]::ReadAllText("$(ChangeLogInTree)"))</PackageReleaseNotes>
				<ChangeLogFinalPath>$(ChangeLogInTree)</ChangeLogFinalPath>
			</PropertyGroup>
			<ItemGroup>
				<!--<None Include="$(ChangeLogInTree)" Pack="True" PackagePath="/" Visible="True" />-->
			</ItemGroup>
		</When>
	</Choose>
	<!-- Description and PackageDescription-->
	<!--A long description for the assembly. If PackageDescription is not specified, then this property is also used as the description of the package.-->
	<Choose>
		<When Condition="Exists('$(DescriptionInTree)')">
			<PropertyGroup>
				<DescriptionFinalContent>$([System.IO.File]::ReadAllText("$(DescriptionInTree)"))</DescriptionFinalContent>
				<DescriptionFinalPath>$(DescriptionInTree)</DescriptionFinalPath>
			</PropertyGroup>
			<ItemGroup>
				<None Include="$(DescriptionInTree)"
				      Pack="True"
				      PackagePath="/"
				      Visible="True" />
			</ItemGroup>
		</When>
		<When Condition="Exists('$(ReadmeFinalPath)')">
			<PropertyGroup>
				<DescriptionFinalContent>$([System.IO.File]::ReadAllText('$(ReadmeFinalPath)'))</DescriptionFinalContent>
				<DescriptionFinalPath>$(ReadmeFinalPath)</DescriptionFinalPath>
			</PropertyGroup>
		</When>
		<When Condition="Exists('$(ChangeLogFinalPath)')">
			<PropertyGroup>
				<DescriptionFinalContent>$([System.IO.File]::ReadAllText('$(ChangeLogFinalPath)'))</DescriptionFinalContent>
				<DescriptionFinalPath>$(ChangeLogFinalPath)</DescriptionFinalPath>
			</PropertyGroup>
		</When>
		<Otherwise>
			<PropertyGroup>
				<!--default description for all packages-->
				<!--<PackageDescription></PackageDescription>-->
			</PropertyGroup>
		</Otherwise>
	</Choose>

	<PropertyGroup>
		<DescriptionFinalContent Condition="$(DescriptionFinalContent.Length)&gt;1000">$(DescriptionFinalContent.SubString(0,1000))</DescriptionFinalContent>
		<Description Condition="'$(DescriptionFinalContent)' !=''">$(DescriptionFinalContent)</Description>
		<!--default description for all packages-->
		<!--<PackageDescription></PackageDescription>-->
	</PropertyGroup>

	<Import Project="Directory.Debug.props"
	        Condition="Exists('Directory.Debug.props')" />
	<Import Project="Directory.Analyzers.props"
	        Condition="Exists('Directory.Analyzers.props')" />
	<Import Project="$(ProjDir)releasenotes.props"
	        Condition="Exists('$(ProjDir)releasenotes.props')" />
	<!--
MSBuild 中，如果一个属性在项目文件中被重复定义了，那么哪一个会生效呢?
这取决于属性的定义顺序和作用域。一般来说，MSBuild 会使用最后一个定义的属性值，除非该属性被标记为不可覆盖（immutable）
如果属性是在全局作用域中重复定义的，那么最后一个定义的值会生效。
如果属性是在条件作用域中重复定义的，那么最后一个满足条件的值会生效。
如果属性是在目标或任务作用域中重复定义的，那么它们会覆盖全局或条件作用域中的值，但只在该目标或任务内有效。
-->
</Project>